---
title: "Quality Control"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r, child = "assets/header-lab.Rmd"}
```

```{r, include = FALSE}
knitr::opts_chunk$set(engine.opts = list(bash = "-l"), chunk.title = TRUE)
```

# Introduction

## What is FastQC?

- Modern high throughput sequencers can generate hundreds of millions of sequences in a single run. Before analysing this sequence to draw biological conclusions you should always perform some simple quality control checks to ensure that the raw data looks good and there are no problems or biases in your data which may affect how you can usefully use it.

- Most sequencers will generate a QC report as part of their analysis pipeline, but this is usually only focused on identifying problems which were generated by the sequencer itself. FastQC aims to provide a QC report which can spot problems which originate either in the sequencer or in the starting library material.

- FastQC can be run in one of two modes. It can either run as a stand alone interactive application for the immediate analysis of small numbers of FastQ files, or it can be run in a non-interactive mode where it would be suitable for integrating into a larger analysis pipeline for the systematic processing of large numbers of files.

## What is Cutadapt?

- Cutadapt finds and removes adapter sequences, primers, poly-A tails and other types of unwanted sequence from your high-throughput sequencing reads.

- Cutadapt helps with trimming tasks by finding the adapter or primer sequences in an error-tolerant way. It can also modify and filter single-end and paired-end reads in various ways. Adapter sequences can contain IUPAC wildcard characters. Cutadapt can also demultiplex your reads.

# Objectives

- [Install FastQC]
- [Install Cutadapt]
- [Sequence quality]
- [Read trimming]

# Tutorial

In this tutorial we are going to learn how to use FastQC and Cutadapt to quality control and trim adapter sequences from FASTQ files. The first thing to do is create a directory to store all the tutorial data. It is good practice to create a new directory for each project you work on, this ensures files do not get mixed up and all the results are self-contained.

Create a 'tutorial' directory to store output files:

```{bash, echo = -1}
rm -rf tutorial
mkdir tutorial
```

Download the tutorial and exercise data:

```{bash}
curl https://raw.githubusercontent.com/zifornd/bioinformatics-workshop/main/data/quality/data.tar.gz --output tutorial/data.tar.gz
```

Extract the archive file into the tutorial directory:

```{bash}
tar xf tutorial/data.tar.gz --directory=tutorial
```

The software we are going to use in this tutorial can be installed using the conda package manager. Please refer to the previous conda workshop for details on installing software and creating conda environments.

## Install FastQC

Create a new environment with FastQC installed:

```{bash}
conda create --yes --name fastqc fastqc
```

Activate the new environment to use it:

```{bash}
conda activate fastqc
```

Test that the `fastqc` command is available:

```{bash, echo = -1, error = TRUE}
conda activate fastqc
which fastqc
```

### Install Cutadapt

Create a new environment with Cutadapt installed:

```{bash}
conda create --yes --name cutadapt cutadapt
```

Activate the new environment to use it:

```{bash}
conda activate cutadapt
```

Test that the `cutadapt` command is available:

```{bash, echo = -1, error = TRUE}
conda activate cutadapt
which cutadapt
```

## Sequence quality

Quality control is an important step in the processing of any type of data. It tells the researcher whether the data is suitable for analysis and whether the conclusions drawn can be trusted. Data integrity however is just one part of the quality control procedure and many other issues, outside of the data, may remain.

In the example data directory are two FASTQ files. The 'good' file has no quality problems and passes all of the FastQC modules. The 'bad' file has lots of problems and would not be suitable for data analysis. Lets run FastQC on both files and compare the results.

Activate the `fastqc` environment:

```{bash}
conda activate fastqc
```

Print the help information for the `fastqc` command:

```{bash, echo = -1}
conda activate fastqc
fastqc --help
```

Create a `fastqc` output directory:

```{bash}
mkdir tutorial/fastqc
```

Run FastQC to generate a quality control report for the 'good' data:

```{bash, echo = -1}
conda activate fastqc
fastqc -o tutorial/fastqc tutorial/data/good.fastq.gz
```

Inspect the `fastqc` output directory:

```{bash}
ls tutorial/fastqc
```

You should see that FastQC generates a `.html` report and a `.zip` folder. The HTML report contains the results from a number of tests which FastQC runs on the sequencing data. For an explanation of the tests, please refer to the FastQC documentation for each one:

- [Basic statistics](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/1%20Basic%20Statistics.html)
- [Per base sequence quality](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/2%20Per%20Base%20Sequence%20Quality.html)
- [Per sequence quality scores](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/3%20Per%20Sequence%20Quality%20Scores.html)
- [Per base sequence content](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/4%20Per%20Base%20Sequence%20Content.html)
- [Per sequence GC content](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/5%20Per%20Sequence%20GC%20Content.html)
- [Per base N content](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/6%20Per%20Base%20N%20Content.html)
- [Sequence length distribution](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/7%20Sequence%20Length%20Distribution.html)
- [Sequence duplication levels](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/8%20Duplicate%20Sequences.html)
- [Overrepresented sequences](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/9%20Overrepresented%20Sequences.html)
- [Adapter content](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/Help/3%20Analysis%20Modules/10%20Adapter%20Content.html)

Inspect the quality control report for the 'good' data:

```{r, echo = FALSE, out.width = "100%"}
knitr::include_url("tutorial/fastqc/good_fastqc.html", height = "800px")
```

The report uses a traffic light system (Green, Yellow, Red) to grade the result from each test (Pass, Warn, Fail). For this particular example, the data passed all of the tests. Once your data passes the majority of these tests it is safe to proceed with any downstream analysis or processing.

Importantly, while these tests are useful, do not rely on them to absolve you of any responsibility. Data which passes all of these tests may still exhibit biases which are not detected, and vice versa. It is important to think about what the tests are measuring and whether those measurements make sense for your particular data.

Lets now extract the `.zip` folder and see what it contains:

```{bash}
unzip -o tutorial/fastqc/good_fastqc.zip -d tutorial/fastqc
```

List all files in the extracted folder:

```{bash}
ls tutorial/fastqc/good_fastqc
```

The folder contains images and supplementary data. The images are those present in the `.html` report so we don't need to look at these again. The others we will look at are the `fastqc_data.txt` and `summary.txt` files.

First, lets display the contents of the `fastqc_data.txt` file:

```{bash}
cat tutorial/fastqc/good_fastqc/fastqc_data.txt
```

As you may have guessed, this file contains all of the data FastQC calculates when running each of the test modules. The layout of the file is not really amenable to processing on the command line so we won't inspect it any further.

Next, display the contents of the `summary.txt` file:

```{bash}
cat tutorial/fastqc/good_fastqc/summary.txt
```

Obviously, this file contains a summary of the results for each test module. The first column lists the result, the second is the test module and the third is the input file. For comparison, lets now run FastQC on the 'bad' file included in the example data directory.

Run FastQC to generate a quality control report for the 'bad' data:

```{bash, echo = -1}
conda activate fastqc
fastqc -o tutorial/fastqc tutorial/data/bad.fastq.gz
```

Inspect the quality control report:

```{r, echo = FALSE, out.width = "100%"}
knitr::include_url("tutorial/fastqc/bad_fastqc.html", height = "800px")
```

As expected, this data has a lot of problems:

- The base sequence quality severely decreases toward the end of the reads
- The tile sequence quality exhibits spots of poor read quality
- The per base sequence content shows a bias toward thymine
- The per sequence GC content does not match the theoretical distribution
- There are lots of over-represented sequences with no identifiable origin
- There appears to be some adapter contamination from the Illumina Paired End PCR Primer 2

So what can we do about this? It would be impractical to re-do the sequencing again and again until we end up with 'good' quality data. Instead, we can process or 'clean' the data using read trimming software. 

## Read trimming

Read trimming is used to 'clean' reads which exhibit adapter contamination or low-quality bases. There is an endless number of read trimming programs available, but all of them basically do the same thing. How fast and how many options they have is usually what differentiates them. We are going to use Cutadapt mainly because of the extensive documentation. Do not underestimate how important and rare well organised and detailed documentation is in the world of bioinformatics software.

In the example data directory is a 'contaminated' FASTQ file. We are going to use this file to demonstrate the effect read trimming has on the quality of the data, as measured by the FastQC report.

Run FastQC to generate a quality control report before trimming:

```{bash, echo = -1}
conda activate fastqc
fastqc -o tutorial/fastqc tutorial/data/contam.fastq.gz
```

Inspect the quality control report:

```{r, echo = FALSE, out.width = "100%"}
knitr::include_url("tutorial/fastqc/contam_fastqc.html", height = "800px")
```

The un-trimmed data has the following issues:

- The per base sequence quality degrades massively
- The per sequence quality scores are quite  variable
- The per sequence GC content does not match the theoretical distribution
- At least 10% of the reads have adapter contamination (Illumina Universal Adapter)

We can use Cutadapt to address these issues by performing read quality and adapter trimming. Cutadapt has a number of options and it would be worth you reading through these at some point to get a sense of what problems can and can't be addressed.

Activate the `cutadapt` environment:

```{bash}
conda activate cutadapt
```

Print the help information for the `cutadapt` command:

```{bash, echo = -1}
conda activate cutadapt
cutadapt --help
```

Create a directory for the `cutadapt` output files:

```{bash}
mkdir tutorial/cutadapt
```

Before we perform read trimming, we need to get the sequence of the contaminating adapter. You can either ask the person who prepared the libraries for the adapter sequence they used or simply search online for the corresponding sequence. Helpfully, Illumina maintains an [adapter sequences document](https://emea.support.illumina.com/downloads/illumina-adapter-sequences-document-1000000002694.html) which lists all of the adapters used in their library preparation kits.

Lets now run Cutadapt to trim the adapter sequence and low quality bases:

```{bash, echo = -1}
conda activate cutadapt
# -q 28             | Trim low-quality bases from 3' end of each read
# -a AGATCGGAAGAGC  | Illumina adapter sequence ligated to the 3' end
# -m 26             | Discard reads shorter than 26 bases
cutadapt -q 28 -a AGATCGGAAGAGC -m 36 -o tutorial/cutadapt/trimmed.fastq.gz tutorial/data/contam.fastq.gz
```

Activate the `fastqc` environment:

```{bash}
conda activate fastqc
```

Run FastQC to generate a quality control report after trimming:

```{bash, echo = -1}
conda activate fastqc
fastqc -o tutorial/fastqc tutorial/cutadapt/trimmed.fastq.gz
```

Inspect the trimmed quality control report:

```{r, echo = FALSE, out.width = "100%"}
knitr::include_url("tutorial/fastqc/trimmed_fastqc.html", height = "800px")
```

You should see that FastQC no longer reports any issues with the per base sequence quality or adapter contamination. However, we still receive a warning for the per sequence GC content. Is this a problem? Remember what I said previously about blindly following the FastQC test results. Does it matter that the GC content is different to this 'theoretical' distribution? What if the data we generated was from an assay that sampled just high GC regions on the genome? An understanding of the data generating process is crucial to assess the FastQC test results in their proper context. Having said that, it appears we have successfully 'cleaned' this data and can proceed with our analysis.

# Exercises

The exercises below are designed to strengthen your knowledge of using FastQC and Cutadapt to perform quality control on sequencing data. The solution to each problem is blurred, only after attempting to solve the problem yourself should you look at the solution. Should you need any help, please ask one of the instructors.

Create a directory to store the output files from each exercise:

```{bash, echo = -1}
rm -rf exercises
mkdir exercises
mkdir exercises/chipseq
mkdir exercises/rnaseq
mkdir exercises/atacseq
```

## ChIP sequencing

> ChIP sequencing, also known as ChIP-seq, is a method used to analyze protein interactions with DNA. ChIP-seq combines chromatin immunoprecipitation (ChIP) with massively parallel DNA sequencing to identify the binding sites of DNA-associated proteins. It can be used to map global binding sites precisely for any protein of interest.

In the data directory is a file called `chipseq.fastq.gz` which contains sequencing data from a ChIP-seq experiment. Use FastQC and Cutadapt to quality check and clean the data if necessary. Pay close attention to the 'Overrepresented sequences' module. Can you clean the data so it passes this module?

```{bash, blur = TRUE}
# Run FastQC on the raw data
conda activate fastqc
fastqc -o exercises/chipseq tutorial/data/chipseq.fastq.gz

# Trim the Illumina TruSeq adapter sequence
# Remove over represented sequences containing any N base calls
conda activate cutadapt
cutadapt -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA --max-n 1 -o exercises/chipseq/chipseq_trimmed.fastq.gz tutorial/data/chipseq.fastq.gz

# Run FastQC on the trimmed data
conda activate fastqc
fastqc -o exercises/chipseq exercises/chipseq/chipseq_trimmed.fastq.gz
```

## RNA sequencing

> RNA-Seq (named as an abbreviation of RNA sequencing) is a sequencing technique which uses next-generation sequencing (NGS) to reveal the presence and quantity of RNA in a biological sample at a given moment, analyzing the continuously changing cellular transcriptome.

In the data directory is a file called `rnaseq.fastq.gz`` which contains sequencing data from an RNA-seq experiment. Use FastQC and Cutadapt to quality check and clean the data if necessary. Pay close attention to the 'Per sequence GC content' and 'Overrepresented sequences' modules. Can you clean the data so both of these modules pass? Should you?

```{bash, blur = TRUE}
# This is an RNA-seq library.
# Depending on the cell type and condition, the GC content of expressed genes might be very skewed.
# The assumptions of the theoretical distribution do not hold for this particular type of data.
# Additionally, it is not clear whether the over-represented sequences are from contamination.
# In an RNA-seq library we expect to see thousands of copies of the same DNA fragment, because a particular gene might be highly expressed.
# The over-represented sequences you observe actually come from a highly expressed gene in the library, not contamination.
```

## ATAC sequencing

> ATAC-seq (Assay for Transposase-Accessible Chromatin using sequencing) is a technique used in molecular biology to assess genome-wide chromatin accessibility. ATAC-seq identifies accessible DNA regions by probing open chromatin with hyperactive mutant Tn5 Transposase that inserts sequencing adapters into open regions of the genome.

In the data directory is a file called `atacseq.fastq.gz` which contains sequencing data from an ATAC-seq experiment. Use FastQC and Cutadapt to quality check and clean the data if necessary. Pay close attention to the 'Per base sequence content' and 'Overrepresented sequences' modules. Can you clean the data so both of these modules pass? If not, think about why?

```{bash, blur = TRUE}
# Run FastQC on the raw data
conda activate fastqc
fastqc -o exercises/atacseq tutorial/data/atacseq.fastq.gz

# Trim the Illumina TruSeq adapter sequence
# Remove over represented sequences containing N base calls
conda activate cutadapt
cutadapt --max-n 1 -o exercises/atacseq/atacseq_trimmed.fastq.gz tutorial/data/atacseq.fastq.gz

# Run FastQC on the trimmed data
conda activate fastqc
fastqc -o exercises/atacseq exercises/atacseq/chipseq_trimmed.fastq.gz

# The 'Per base sequence content' module fails because of the strange pattern at the beginning of the read.
# This is not due to contamination or a probably with the library.
# The ATAC-seq protocol uses a Tn5 transposase which inserts itself into regions of open DNA.
# Those regions of open DNA are what go on to be sequenced.
# The strange pattern you observe is due to a bias in the Tn5 transposase itself - it has a tendency to insert itself into regions of the DNA with a particular sequence composition.
```
