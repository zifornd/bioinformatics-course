---
title: "Analysis of RNA-seq data"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r,child="assets/header-lab.Rmd"}
```

```{r, include=FALSE}
knitr::opts_chunk$set(chunk.title = TRUE, engine.opts = list(bash = "-l"), fig.align = "center")
```

# Introduction

Here we walk through an end-to-end gene-level RNA-Seq differential expression workflow using command-line tools and Bioconductor packages. We will start from the FASTQ files, show how to align these to the reference genome, and prepare a count matrix which tallies the number of RNA-seq reads/fragments within each gene for each sample. We will perform exploratory data analysis (EDA) for quality assessment and to explore the relationship between samples, perform differential gene expression analysis, and visually explore the results.

## Analysis workflow

There are at least four distinct phases of analysis (Figure \@ref(fig:rnaseq-analysis-workflow-full)). The first phase takes the raw sequence reads generated by a sequencing platform and maps them to the genome or transcriptome. Phase 2 quantifies the number of reads associated with each gene or transcript (an expression matrix). This process may involve one or more distinct sub-stages of alignment, assembly and quantification, or it may holistically generate the expression matrix from read counts in a single step. Usually there is a third phase where the expression matrix is altered by filtering lowly expressed features, as well as the crucial step of normalizing the raw counts to account for technical differences between the samples. The final phase in DGE is statistical modelling of the sample groups and covariates, to calculate confidence statistics related to differential expression.

![(#fig:rnaseq-analysis-workflow-full) RNA-seq data analysis workflow for differential gene expression ](data/rnaseq/images/rnaseq-analysis-workflow-full.png)

In this tutorial we will follow workflow A: aligners such as TopHat, STAR or HISAT2 use a reference genome to map reads to genomic locations, and then quantification tools, such as HTSeq and featureCounts, assign reads to features. After normalization (usually using methods embedded in the quantification or expression modelling tools, such as trimmed mean of M-values (TMM)), gene expression is modelled using tools such as edgeR, DESeq2 and limma+voom, and a list of differentially expressed genes or transcripts is generated for further visualization and interpretation.

## Bioconductor packages

Bioconductor is a free, open source and open development software project for the analysis and comprehension of genomic data generated by wet lab experiments in molecular biology. Bioconductor is based primarily on the statistical R programming language, but does contain contributions in other programming languages. It has two releases each year that follow the semiannual releases of R. At any one time there is a release version, which corresponds to the released version of R, and a development version, which corresponds to the development version of R. Most users will find the release version appropriate for their needs.

Bioconductor has many packages which support analysis of high-throughput sequence data, including RNA sequencing (RNA-seq). The packages which we will cover in this tutorial include core packages maintained by the Bioconductor core team for importing and processing raw sequencing data and loading gene annotations. We will also cover contributed packages for statistical analysis and visualization of sequencing data. Through scheduled releases every 6 months, the Bioconductor project ensures that all the packages within a release will work together in harmony (hence the “conductor” metaphor).

The packages used in this tutorial are loaded with the library function and can be installed by following the [Bioconductor package installation instructions](https://bioconductor.org/install/#install-bioconductor-packages) or using the conda package manager. A list of all the packages loaded in this tutorial is included at the end, in the Session information section.

# Objectives

* [Data preparation]
* [Software installation]
* [Read alignment]
* [Gene quantification]
* [Differential expression]

# Tutorial

The commands used in the tutorial should all be run from the Unix shell prompt within a terminal window up to the differential expression analysis, which is performed in the R environment. We encourage users to create a single directory (e.g., ‘tutorial’) in which to store all example data and files created by the analysis. The tutorial also includes small sections of code to be run in the R statistical computing environment. Commands meant to be executed from the Unix shell (e.g., bash or csh) have the chunk title ‘BASH’. Commands
that are meant to be run from either an R script or at the R interactive shell have the chunk title ‘R’.

Create a *tutorial* directory to store all data and output files:

```{bash, echo = -1}
rm -rf tutorial
mkdir tutorial
```

## Data preparation

The tutorial is illustrated with an example experiment from chromosome 22 of *Homo sapiens* that you can use to familiarize yourself with the analysis of RNA-seq data. All of the data you will need are available in the file *griffith.tar.gz*, which you will have to download. The data consists of two commercially available RNA samples: Universal Human Reference (UHR) and Human Brain Reference (HBR). The UHR is total RNA isolated from a diverse set of 10 cancer cell lines. The HBR is total RNA isolated from the brains of 23 Caucasians, male and female, of varying age but mostly 60-80 years old.

Download the data archive file into the *tutorial* directory.

```{bash}
curl https://media.githubusercontent.com/media/zifornd/bioinformatics-workshop/main/data/rnaseq/griffith.tar.gz --output tutorial/griffith.tar.gz
```

Extract the data archive file into the *tutorial* directory.

```{bash}
tar xf tutorial/griffith.tar.gz --directory=tutorial
```

Inspect the contents of the tutorial data.

```{bash}
ls tutorial/data
```

The data archive file expands to contain a single directory *data* with three directories:

  * The *samples* directory contains paired-end RNA-seq reads from 6 samples, with 3 samples from each of two conditions, HBR (Human Brain Reference) and UHR (Universal Human Reference). For each condition there are three replicates. All sequencing data is in compressed ‘fastq’ format, which stores each read on four lines. Each sample in turn is contained in two files: one for read 1 and another for read 2 of each pair. Thus, for example, sample HBR_Rep1 is contained in files HBR_Rep1_1.fastq.gz and HBR_Rep1_2.fastq.gz.
  
```{bash}
ls tutorial/data/samples
```

  * The *genome* directory contains one file, chr22.fa, which is the DNA sequence of human chromosome 22.

```{bash}
ls tutorial/data/genome
```
  
  * The *genes* directory contains one file, chr22.gtf, which is the gene annotations from human chromosome 22.

```{bash}
ls tutorial/data/genes
```

The *data* directory also contains three text files:

  * The *conda.txt* file contains the list of software required for the tutorial. This file can be used to create a conda environment.

```{bash}
cat tutorial/data/conda.txt
```

  * The *targets.txt* file contains the sample names, one per line. This file will be used as input to for loops on the command line so you do not have to re-write the same command with each sample name.

```{bash}
cat tutorial/data/targets.txt
```

  * The *samples.tsv* file contains the name and condition for each sample. This file will be used in the differential expression analysis to specify which samples belong to which condition.

```{bash}
cat tutorial/data/samples.tsv
```

Normally you would create these files yourself in a text editor, but we provide them here for use as examples. Finally, create an output directory to store all the output files.

```{bash}
rm -rf tutorial/output
mkdir tutorial/output
```

## Software installation

All of the software required for this tutorial can be installed using the conda package manager. The *data* directory contains a text file called *conda.txt* which can be used to create a conda environment.

Create a new environment from the `conda.txt` file.

```{bash}
conda create --name rnaseq --yes --file tutorial/data/conda.txt
```

Activate the new environment.

```{bash}
conda activate rnaseq
```

Verify that the new environment was installed correctly.

```{bash}
conda env list
```

## Read alignment

After sequencing has been completed, the starting point for analysis is the data files, which contain base-called sequencing reads, usually in the form of FASTQ files. The most common first step in processing these files is to map sequence reads to a known transcriptome (or annotated genome, converting each sequence read to one or more genomic coordinates. This process has traditionally been accomplished using distinct alignment tools, such as TopHat, STAR or HISAT, which rely on a reference genome. Because the sequenced cDNA is derived from RNA, which may span exon boundaries, these tools perform a spliced alignment allowing for gaps in the reads when compared to the reference genome (which contains introns as well as exons). In this step of the workflow we will use HISAT2, the second major release of the HISAT splice-aware aligner.

Create a directory to store HISAT2 output files.

```{bash}
mkdir tutorial/output/hisat2
```

Build the HISAT2 index.

```{bash}
conda activate rnaseq
hisat2-build tutorial/data/genome/chr22.fa tutorial/output/hisat2/chr22.fa
```

Map the reads for each sample to the reference genome.

```{bash}
conda activate rnaseq
while read SAMPLE; do

  IDX=tutorial/output/hisat2/chr22.fa
  FQ1=tutorial/data/samples/${SAMPLE}_1.fastq.gz
  FQ2=tutorial/data/samples/${SAMPLE}_2.fastq.gz
  SAM=tutorial/output/hisat2/${SAMPLE}.sam

  hisat2 $IDX -1 $FQ1 -2 $FQ2 -S $SAM

done < tutorial/data/targets.txt
```

Sort and convert the SAM files to BAM.

```{bash}
conda activate rnaseq
while read SAMPLE; do

  SAM=tutorial/output/hisat2/${SAMPLE}.sam
  BAM=tutorial/output/hisat2/${SAMPLE}.bam
  
  samtools sort -o $BAM $SAM

done < tutorial/data/targets.txt
```

Index the BAM files.

```{bash}
conda activate rnaseq
while read SAMPLE; do

  BAM=tutorial/output/hisat2/${SAMPLE}.bam
    
  samtools index $BAM

done < tutorial/data/targets.txt
```

Note, the above commands could have been run in the same for-loop, however for ease of understanding we have split them into separate chunks. This is also useful when an error occurs and it is not obvious which of the commands was responsible for the error. For example, the samtools sort command may have throw an error, but it could have been caused by an empty SAM file created by the aligner. The cause of the problem would not have been immediatley obvious if all of the commands were run together.

Inspect the contents of the *hisat2* output folder.

```{bash}
ls tutorial/output/hisat2
```

## Gene quantification

Once reads have been mapped to genomic locations, the next step in the analysis process is to assign them to genes, to determine abundance measures. The quantification of read abundances for individual genes (that is, all transcript isoforms for that gene) relies on counting sequence reads that overlap known genes, using a transcriptome annotation. Quantification tools in common use include RSEM, HTSeq133, and featureCounts. The results of the quantification step are usually combined into an expression matrix, with a row for each gene and a column for each sample, with the values being actual read counts. In this step of the workflow we will use featureCounts by calling it from R using the Rsubread package.

First, we need to load the sample table in R. An example file called *samples.tsv* is included with the
data files for this tutorial. In general, you will have to create this file yourself. It contains information about your RNA-seq samples, formatted as illustrated in the tsv (tab-separated values) file. Each sample should
be described on one row of the file, and each column should contain one variable. To read this file into R, we use the command `read.delim`.

```{r}
samples <- read.delim("tutorial/data/samples.tsv")
samples
```

Construct path to BAM files created by the read alignment step.

```{r}
files <- file.path("tutorial/output/hisat2", paste0(samples$sample, ".bam"))
files
```

Load the Rsubread package which contains the *featureCounts* function.

```{r}
library(Rsubread)
```

Inspect the documentation for the *featureCounts* function.

```{r}
# This will open the help page in your R console
help(featureCounts)
```

Assign mapped sequencing reads to genes.

```{r}
output <- featureCounts(
  files,
  annot.ext = "tutorial/data/genes/chr22.gtf",
  isGTFAnnotationFile = TRUE,
  isPairedEnd = TRUE,
  countReadPairs = TRUE
)
```

Inspect the first few rows of the count matrix.

```{r}
head(output$counts)
```

In the count matrix, each row represents a gene, each column a sample, and the values give the raw numbers of fragments that were uniquely assigned to the respective gene in each sample.

## Differential expression

Once sequence reads have been processed into an expression matrix, the experiment can be modelled to determine which genes are likely to have changed their level of expression between conditions. Several tools are commonly used to accomplish this; some model read counts of gene-level expression, whereas others rely on transcript-level estimates. Gene-level tools typically rely on aligned read counts and use generalized linear models that enable complex experimental set-ups to be evaluated. These include tools such as edgeR, DESeq2 and limma+voom, which are computationally efficient and provide comparable results. In this step of the workflow we will use DESeq2, a package to perform differential gene expression analysis based on the negative binomial distribution.

Load the DESeq2 package.

```{r}
library(DESeq2)
```

### The *DESeqDataset* object

In this section we will show how to create the data object used by DESeq2. The object class used by the DESeq2 package to store the read counts and the intermediate estimated quantities during statistical analysis is the *DESeqDataSet*, which will usually be represented in the code here as an object `dds`.

A DESeqDataSet object must have an associated design formula. The design formula expresses the variables which will be used in modeling. The formula should be a tilde (~) followed by the variables with plus signs between them (it will be coerced into an formula if it is not already). The design can be changed later, however then all differential analysis steps should be repeated, as the design formula is used to estimate the dispersions and to estimate the log2 fold changes of the model.

The simplest design formula for differential expression would be `~ condition`, where `condition` is a column in the `colData` that specifies which of two (or more groups) the samples belong to. For this experiment, we will specify `~ condition` meaning that we want to test for the effect of condition.

To construct a *DESeqDataSet* object from a matrix of counts and the sample information table, we use the *DESeqDataSetFromMatrix* function.

```{r}
dds <- DESeqDataSetFromMatrix(countData = output$counts, colData = samples, design = ~ condition)
dds
```

The *DEseqDataSet* object class is built on top of the *SummarizedExperiment* class (Figure \@ref(fig:summarized-experiment-class)). The *SummarizedExperiment* class is used to store rectangular matrices of experimental results, which are commonly produced by sequencing and microarray experiments. Each object stores observations of one or more samples, along with additional meta-data describing both the observations (features) and samples (phenotypes). A key aspect of the SummarizedExperiment class is the coordination of the meta-data and assays when subsetting. For example, if you want to exclude a given sample you can do for both the meta-data and assay in one operation, which ensures the meta-data and observed data will remain in sync. For further information, refer to the *SummarizedExperiment* [documentation](https://bioconductor.org/packages/release/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html)

![(#fig:summarized-experiment-class) Schematic of the SummarizedExperiment class](data/rnaseq/images/summarized-experiment-class.svg){width=75%}

### Pre-filtering the dataset

While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: by removing rows in which there are very few reads, we reduce the memory size of the data object, and we increase the speed of the transformation and testing functions within DESeq2. Here we perform a minimal pre-filtering to keep only rows that have at least 10 reads total.

```{r}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep, ]
```

### Running the differential expression pipeline

As we have already specified an experimental design when we created the *DESeqDataSet*, we can run the differential expression pipeline on the raw counts with a single call to the function DESeq.

```{r}
dds <- DESeq(dds)
```

This function will print out a message for the various steps it performs. These are described in the manual page for *DESeq*, which can be accessed by typing `?DESeq`. Complete details and motivations for the statistical procedures that occur within the *DESeq* function are described in the *DESeq2* article. Briefly these steps are:

1. The estimation of size factors, controlling for differences in the counts due varying sequencing depth of the samples.

2. The estimation of dispersion values. The dispersion parameter captures how much the counts for the samples will vary around an expected value. Note that the expected value takes into consideration the sequencing depth and differences that can be attributed to variables in the design formula.

3. Fitting a final generalized linear model using the size factors and dispersion values estimated above, which gives estimates of the log fold changes.

A *DESeqDataSet* is returned that contains all the fitted parameters within it, and the following section describes how to extract out results tables of interest from this object.

### Building the results table

In general, the results for a comparison of any two levels of a variable can be extracted using the `contrast` argument to *results*. The user should specify three values: the name of the variable, the name of the level for the numerator, and the name of the level for the denominator. Here we extract results for the log2 of the fold change of one cell line over another.

```{r}
res <- results(dds, contrast = c("condition", "HBR", "UHR"))
res
```

As res is a DataFrame object, it carries metadata with information on the meaning of the columns.

```{r}
mcols(res, use.names = TRUE)
```

The first column, `baseMean`, is a just the average of the normalized count values, dividing by size factors, taken over all samples in the *DESeqDataSet*. The remaining four columns refer to a specific contrast, namely the comparison of the `HBR` level over the `UHR` level for the factor variable `condition`.

The column `log2FoldChange` is the effect size estimate. It tells us how much the gene’s expression seems to have changed between conditions. This value is reported on a logarithmic scale to base 2: for example, a log2 fold change of 1.5 means that the gene’s expression is increased by a multiplicative factor of 2^1.5 ≈ 2.82.

Of course, this estimate has an uncertainty associated with it, which is available in the column `lfcSE`, the standard error estimate for the log2 fold change estimate. We can also express the uncertainty of a particular effect size estimate as the result of a statistical test. The purpose of a test for differential expression is to test whether the data provides sufficient evidence to conclude that this value is really different from zero. DESeq2 performs for each gene a *hypothesis* test to see whether evidence is sufficient to decide against the *null hypothesis* that there is zero effect of the treatment on the gene and that the observed difference between treatment and control was merely caused by experimental variability (i.e., the type of variability that you can expect between different samples in the same treatment group).

As usual in statistics, the result of this test is reported as a *p* value, and it is found in the column `pvalue`. A *p* value indicates the probability that a fold change as strong as the observed one, or even stronger, would be seen under the situation described by the null hypothesis. The adjusted *p* values satisfy the property that thresholding at a specific value defines a set of tests (one for each gene) with a bounded false discovery rate (FDR), typically a useful metric for assessing which genes to target for further analysis. For example, the set of genes with adjusted p value less than 0.1 should contain no more than 10% false positives.

We can also summarize the results with the following line of code, which reports some additional information.

```{r}
summary(res)
```

### Plotting results

A quick way to visualize the counts for a particular gene is to use the *plotCounts* function that takes as arguments the *DESeqDataSet*, a gene name, and the group over which to plot the counts.

```{r, fig.cap = "Normalized counts for a single gene over condition group."}
top <- rownames(res)[which.min(res$padj)]
plotCounts(dds, gene = top, intgroup = "condition")
```

Another plot we can genrate, is a so-called MA-plot - this provides a useful overview for an experiment with a two-group comparison.

```{r, fig.cap = "An MA-plot of changes induced by condition."}
plotMA(res)
```

The log2 fold change for a particular comparison is plotted on the y-axis and the average of the counts normalized by size factor is shown on the x-axis (“M” for minus, because a log ratio is equal to log minus log, and “A” for average). Each gene is represented with a dot. Genes with an adjusted p value below a threshold (here 0.1, the default) are shown in blue.

### Annotating results

Our result table so far only contains information about Ensembl gene IDs, but alternative gene names may be more informative for collaborators. Bioconductor’s annotation packages help with mapping various ID schemes to each other. We load the AnnotationDbi package and the annotation package org.Hs.eg.db:

```{r}
library(AnnotationDbi)
library(org.Hs.eg.db)
```

This is the organism annotation package (“org”) for Homo sapiens (“Hs”), organized as an AnnotationDbi database package (“db”), using Entrez Gene IDs (“eg”) as primary key. To get a list of all available key types, use:

```{r}
columns(org.Hs.eg.db)
```

We can use the *mapIds* function to add individual columns to our results table. We provide the row names of our results table as a key, and specify that keytype=ENSEMBL. The `column` argument tells the *mapIds* function which information we want, and the `multiVals` argument tells the function what to do if there are multiple possible values for a single input value. Here we ask to just give us back the first one that occurs in the database. To add the gene symbol and Entrez ID, we call *mapIds* twice.

```{r}
ids <- strsplit(rownames(res), ".", fixed = TRUE)

ids <- sapply(ids, head, n = 1)

res$symbol <- mapIds(
  x = org.Hs.eg.db,
  keys = ids,
  column = "SYMBOL",
  keytype = "ENSEMBL",
  multiVals = "first"
)

res$entrez <- mapIds(
  x = org.Hs.eg.db,
  keys = ids,
  column = "ENTREZID",
  keytype = "ENSEMBL",
  multiVals = "first"
)
```

Now the results have the desired external gene IDs:

```{r}
# Output the first few lines of the results table
head(res)
```

### Exporting results

A plain-text file of the results can be exported using the base R functions *write.csv* or *write.delim*. We suggest using a descriptive file name indicating the variable and levels which were tested.

```{r}
write.csv(as.data.frame(res), file = "tutorial/output/HBR-UHR.results.csv")
```

Exporting only the results which pass an adjusted *p* value threshold can be accomplished with the subset function, followed by the *write.csv* function.

```{r}
sig <- subset(res, padj < 0.1)
write.csv(as.data.frame(sig), file = "tutorial/output/HBR-UHR.signif.csv")
```

### Session information

As the last part of this document, we call the function sessionInfo, which reports the version numbers of R and all the packages used in this session. It is good practice to always keep such a record of this as it will help to trace down what has happened in case an R script ceases to work or gives different results because the functions have been changed in a newer version of one of your packages. By including it at the bottom of a script, your reports will become more reproducible.

```{r}
sessionInfo()
```

# References

This tutorial was produced from a number of different online tutorials and review articles. Most of the text has been duplicated verbatim or adapted to fit the tutorial objectives.

* [RNA-Seq workflow: gene-level exploratory analysis and differential expression](https://f1000research.com/articles/4-1070)

* [Transcript-level expression analysis of RNA-seq experiments with HISAT, StringTie and Ballgown](https://www.nature.com/articles/nprot.2016.095)

* [RNA-seq Bioinformatics](https://rnabio.org)

* [RNA sequencing: the teenage years](https://www.nature.com/articles/s41576-019-0150-2)

<!-- Clean up conda and files -->

```{bash, include = FALSE}
rm -rf tutorial
conda remove --name rnaseq --all --yes
```

```{r,child="assets/footer-lab.Rmd"}
```
